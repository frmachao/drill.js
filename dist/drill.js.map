{"version":3,"sources":["../src/drill.js"],"names":[],"mappings":"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","file":"drill.js","sourcesContent":["((glo) => {\n    \"use strict\";\n    //common\n    const windowHead = document.head;\n\n    const\n    //模块处理中 \n        PENDING = \"pending\",\n        //模块加载成功\n        RESOLVED = \"resolved\",\n        //模块加载失败\n        REJECTED = \"rejected\",\n        //js加载完成，但是模块定义未完成\n        LOADED = \"loaded\";\n\n    //映射资源\n    var paths = {};\n\n    //映射目录\n    var dirpaths = {};\n\n    //载入模块用的map对象\n    var dataMap = {};\n\n    //基础数据对象\n    var baseResources = {\n        paths: paths,\n        dirpaths: dirpaths,\n        //js模块相对路径\n        baseUrl: \"\",\n        dataMap: dataMap,\n        //临时挂起的模块对象\n        tempM: {}\n    };\n\n    //function\n    //转换成array类型\n    var arrayslice = Array.prototype.slice;\n    var makeArray = arrobj => arrayslice.call(arrobj);\n\n    //获取类型\n    var objectToString = Object.prototype.toString;\n    var getType = value => objectToString.call(value).toLowerCase().replace(/(\\[object )|(])/g, '');\n\n    //array类型的遍历\n    var arrayEach = (arr, func) => {\n        !(arr instanceof Array) && (arr = makeArray(arr));\n        arr.some((e, i) => func(e, i) === false);\n        return arr;\n    };\n\n    //获取目录名\n    var getDir = (url) => {\n        let urlArr = url.match(/(.+\\/).+/);\n        return urlArr && urlArr[1];\n    };\n\n    //修正字符串路径\n    var removeParentPath = (url) => {\n        let urlArr = url.split(/\\//g);\n        let newArr = [];\n        arrayEach(urlArr, (e) => {\n            if (e == '..' && newArr.length && (newArr.slice(-1)[0] != \"..\")) {\n                newArr.pop();\n                return;\n            }\n            newArr.push(e);\n        });\n        return newArr.join('/');\n    };\n\n    //改良异步方法\n    var nextTick = (() => {\n        let isTick = false;\n        let nextTickArr = [];\n        return (fun) => {\n            if (!isTick) {\n                isTick = true;\n                setTimeout(() => {\n                    for (let i = 0; i < nextTickArr.length; i++) {\n                        nextTickArr[i]();\n                    }\n                    nextTickArr = [];\n                    isTick = false;\n                }, 0);\n            }\n            nextTickArr.push(fun);\n        };\n    })();\n\n    //是否空对象\n    var isEmptyObj = (obj) => {\n        for (let i in obj) {\n            return 0;\n        }\n        return 1;\n    }\n\n    //是否undefined\n    var isUndefined = val => val === undefined;\n\n    //返回Promise实例\n    var promise = func => new Promise(func);\n\n    //main\n    //主业务逻辑\n    var R = {\n        //加载script的方法\n        loadScript: url => {\n            let script = document.createElement('script');\n\n            //判断版本号\n            let { k, v } = drill.cacheInfo;\n            if (k && v) {\n                if (url.search(/\\?/) > -1) {\n                    url += \"&\" + k + \"=\" + v;\n                } else {\n                    url += \"?\" + k + \"=\" + v;\n                }\n            }\n\n            //填充相应数据\n            script.type = 'text/javascript';\n            script.async = true;\n            script.src = url;\n\n            //ie10对 async支持差的修正方案\n            nextTick(() => {\n                windowHead.appendChild(script);\n            });\n\n            return script;\n        },\n        //根据数组内的路径进行封装返回Promise对象\n        toProm: (args, pubData) => {\n            let pendFun;\n\n            let pms = promise((res, rej) => {\n                let arr = [];\n                let len = args.length;\n\n                //确认返回数据的方法\n                let monitFun = () => {\n                    len--;\n                    if (!len) {\n                        pendFun = null;\n                        if (arr.length == 1) {\n                            res(arr[0]);\n                        } else {\n                            res(arr);\n                        };\n                    }\n                };\n\n                arrayEach(args, (e, i) => {\n                    //获取实际路径\n                    let path = R.getPath(e, pubData);\n\n                    //获取promise模块\n                    let p = R.agent(path, pubData);\n\n                    p.then((data) => {\n                        arr[i] = data;\n                        pendFun && pendFun(data, i);\n                        monitFun();\n                    }).catch((err) => {\n                        rej(err);\n                    });\n                });\n            });\n\n            //加入pend事件\n            pms.pend = (func) => {\n                pendFun = func;\n                return pms;\n            };\n\n            return pms;\n        },\n        //载入单个资源的代理方法\n        agent: (path, pubData) => promise((res, rej) => {\n            let tar = dataMap[path];\n            if (tar) {\n                switch (tar.state) {\n                    case LOADED:\n                    case PENDING:\n                        tar.c.push({\n                            res,\n                            pubData\n                        });\n                        break;\n                    case RESOLVED:\n                        nextTick(() => {\n                            if (tar.get) {\n                                tar.get((data) => {\n                                    res(data);\n                                }, pubData);\n                            } else {\n                                res();\n                            }\n                        });\n                        break;\n                    case REJECTED:\n                        nextTick(() => {\n                            rej();\n                        });\n                        break;\n                }\n            } else {\n                dataMap[path] = tar = {\n                    //模块类型\n                    // type: \"file\",\n                    state: PENDING,\n                    c: [{\n                        res,\n                        pubData\n                    }]\n                };\n\n                let script = R.loadScript(path);\n\n                script.onload = () => {\n                    tar.state = LOADED;\n                    R.setTemp(path);\n                    baseResources.tempM = {};\n                };\n                script.onerror = () => {\n                    while (0 in tar.c) {\n                        tar.c.shift().rej();\n                    }\n                    baseResources.tempM = {};\n                    tar.state = REJECTED;\n                    delete tar.c;\n                }\n            }\n        }),\n        //设定temp的方法\n        setTemp: path => {\n            //获取模块数据\n            let { tempM } = baseResources;\n            let data = tempM.d;\n            let { ids } = tempM;\n\n            //查看是否有设定ids\n            (ids && getType(ids) == \"string\") && (ids = [ids]);\n\n            let tar = dataMap[path];\n\n            //默认模块为普通文件类型\n            let type = tar.type = (tempM.type || \"file\");\n\n            //判断是否有自定义id\n            if (ids) {\n                arrayEach(ids, (e) => {\n                    dataMap[e] = tar;\n                });\n            }\n\n            //运行成功\n            let runFunc = d => {\n                //响应队列resolve函数\n                while (0 in tar.c) {\n                    tar.c.shift().res(d);\n                }\n\n                //设置返回数据的方法\n                tar.get = (callback) => {\n                    callback(d);\n                };\n\n                //设置完成\n                tar.state = RESOLVED;\n\n                //清除无用数据\n                delete tar.c;\n            }\n\n            //根据类型做不同的处理\n            switch (type) {\n                //普通文件类型\n                case \"file\":\n                    runFunc();\n                    break;\n                    //模块类型\n                case \"define\":\n                    //判断是否是函数\n                    if (getType(data).search('function') > -1) {\n                        let exports = {},\n                            module = {\n                                exports: exports\n                            };\n\n                        //判断返回值是否promise\n                        let p = data.bind({\n                            FILE: path\n                        })(function() {\n                            return R.require(makeArray(arguments), {\n                                rel: path\n                            });\n                        }, exports, module);\n\n                        if (p instanceof Promise) {\n                            p.then((d) => {\n                                if (isUndefined(d) && getType(module.exports) == \"object\" && !isEmptyObj(module.exports)) {\n                                    d = module.exports;\n                                }\n                                runFunc(d);\n                            });\n                        } else {\n                            //数据类型\n                            runFunc(p);\n                        }\n                    } else {\n                        runFunc(data);\n                    }\n                    break;\n                    //任务类型\n                case \"task\":\n                    runFunc = null;\n                    //设定数据值\n                    if (getType(data).search('function') > -1) {\n                        let getFun = tar.get = (res, pubData) => {\n                            let p = data(function() {\n                                return R.require(makeArray(arguments), {\n                                    rel: path\n                                });\n                            }, pubData.pdata);\n                            p.then((d) => {\n                                res(d);\n                            });\n                        };\n\n                        //响应队列resolve函数\n                        while (0 in tar.c) {\n                            let {\n                                res,\n                                pubData\n                            } = tar.c.shift();\n                            getFun(res, pubData);\n                        }\n                    } else {\n                        throw 'task module type error';\n                    }\n\n                    //设置完成\n                    tar.state = RESOLVED;\n\n                    //清除无用数据\n                    delete tar.c;\n                    break;\n            };\n        },\n        //转换路径\n        getPath: (target, pubData) => {\n            let relatePath = pubData.rel;\n            //判断是否已经注册了路径\n            if (paths[target]) {\n                target = paths[target];\n            } else {\n                let tarreg, res;\n                //判断是否注册目录\n                for (let i in dirpaths) {\n                    tarreg = new RegExp('^' + i);\n                    res = tarreg.test(target);\n                    if (res) {\n                        target = target.replace(tarreg, dirpaths[i]);\n                        break\n                    }\n                }\n            }\n\n            //判断是否带协议头部\n            //没有协议\n            if (!/^.+?\\/\\//.test(target)) {\n                //是否带参数\n                if (!/\\?.+$/.test(target) && !/.js$/.test(target)) {\n                    //没有js的话加上js后缀\n                    target += \".js\";\n                }\n\n                //判断是否有相对路径字样\n                let rePath = target.match(/^\\.\\/(.+)/);\n                if (rePath) {\n                    //获取相对目录\n                    target = getDir(relatePath) + rePath[1];\n                } else {\n                    //加上根目录\n                    target = baseResources.baseUrl + target;\n                }\n\n                //去除相对上级目录\n                target = removeParentPath(target);\n            }\n            return target;\n        },\n        //引用模块\n        require: (args, pubData = {}) => {\n            let p = R.toProm(args, pubData);\n\n            //添加post方法\n            p.post = (data) => {\n                pubData.pdata = data;\n                return p;\n            }\n            return p;\n        },\n        //定义模块\n        define: (d, ids) => {\n            baseResources.tempM = {\n                type: \"define\",\n                d: d,\n                ids: ids\n            };\n        },\n        //定义进程\n        task: (d, ids) => {\n            baseResources.tempM = {\n                type: \"task\",\n                d: d,\n                ids: ids\n            };\n        }\n    };\n\n    //主体require\n    var require = function() {\n        return R.require(makeArray(arguments));\n    };\n    var oDefine = (d, ids) => {\n        R.define(d, ids);\n    };\n    var oTask = (d, ids) => {\n        R.task(d, ids);\n    }\n\n    var drill = {\n        config: data => {\n            //配置baseurl\n            baseResources.baseUrl = data.baseUrl || \"\";\n\n            //配置paths\n            for (let i in data.paths) {\n                if (/\\/$/.test(i)) {\n                    //属于目录类型\n                    dirpaths[i] = data.paths[i];\n                } else {\n                    //属于资源类型\n                    paths[i] = data.paths[i];\n                }\n            }\n        },\n        remove: url => {\n            //获取路径\n            let path = R.getPath(url);\n\n            //获取寄存对象\n            let tarData = dataMap[path];\n\n            if (tarData) {\n                delete dataMap[path];\n                //告示删除成功\n                return true;\n            }\n        },\n        //扩展函数\n        extend: fun => {\n            fun(baseResources, R);\n        },\n        require: require,\n        define: oDefine,\n        task: oTask,\n        //缓存版本号\n        cacheInfo: {\n            k: \"srcache\",\n            // v: \"\"\n        }\n    };\n\n\n    //init\n    glo.require || (glo.require = require);\n    glo.define || (glo.define = oDefine);\n    glo.task || (glo.task = oTask);\n    glo.drill = drill;\n\n    window.baseResources = baseResources;\n\n})(window);"]}