/*!
* drill.js v3.5.4
* https://github.com/kirakiray/drill.js
* 
* (c) 2018-2021 YAO
* Released under the MIT License.
*/(glo=>{"use strict";const getRandomId=()=>Math.random().toString(32).substr(2);var objectToString=Object.prototype.toString,getType=e=>objectToString.call(e).toLowerCase().replace(/(\[object )|(])/g,"");const isFunction=e=>getType(e).search("function")>-1;var isEmptyObj=e=>!(0 in Object.keys(e));const nextTick=(()=>{if("undefined"!=typeof $&&void 0!==$.nextTick)return $.nextTick;if(null!==document.currentScript.getAttribute("debug"))return setTimeout;if("object"==typeof process&&process.nextTick)return process.nextTick;let e=!1,t=[];return a=>{e||(e=!0,setTimeout(()=>{for(let e=0;e<t.length;e++)t[e]();t=[],e=!1},0)),t.push(a)}})(),getFileType=e=>{let t,a=e.split("/").pop().match(/(.+)\.(.+)/);return a&&(t=a[2]),t},getDir=e=>{let t=(e=(e=e.replace(/(.+)#.+/,"$1")).replace(/(.+)\?.+/,"$1")).match(/(.+\/).*/);return t&&t[1]},getFullPath=(e,t)=>{!t&&(t=getDir(document.location.href));let a=e;return/^.+:\/\//.test(t)||(t=getDir(getFullPath(t))),/^.+:\/\//.test(e)||(a=/^\/.+/.test(e)?location.origin+e:t+e),a},removeParentPath=e=>{let t=[];return e.split(/\//g).forEach(e=>{".."==e&&t.length&&".."!=t.slice(-1)[0]?t.pop():t.push(e)}),t.join("/")},processors=new Map,loaders=new Map,bag=new Map,paths=new Map,dirpaths={};let offline=!1;const cacheDress=new Map;let errInfo={time:100,backups:[]},baseUrl=getDir(location.href),base={processors:processors,loaders:loaders,bag:bag,paths:paths,dirpaths:dirpaths,errInfo:errInfo,baseUrl:"",tempM:{}};loaders.set("css",e=>new Promise((t,a)=>{let r=document.createElement("link");r.rel="stylesheet",r.href=e.link;let s=!1;r.onload=(async()=>{t(async e=>(s||(s=!0,e.param.includes("-unAppend")&&document.head.removeChild(r)),r))}),r.onerror=(e=>{a({desc:"load link error",target:r,event:e})}),document.head.appendChild(r)})),loaders.set("json",async e=>{let t=await fetch(e.link);return t=await t.json(),async()=>t}),loaders.set("wasm",async e=>{let t=await fetch(e.link);t=await t.arrayBuffer();let a=await WebAssembly.compile(t);const r=new WebAssembly.Instance(a);return async()=>r.exports}),loaders.set("frame",async e=>{let t=document.createElement("iframe");Object.assign(t.style,{position:"absolute","z-index":"-1",border:"none",outline:"none",opacity:"0",width:"0",height:"0"});let{link:a,path:r}=e,s=r.replace(/\.frame$/,"/frame.html"),i=a.replace(r,s);t.src=i;let l=new Map,n=()=>{bag.delete(r),document.body.removeChild(t),window.removeEventListener("message",o),o=e=n=null};e.timer=setTimeout(n,1e4);let o,c=a=>new Promise(r=>{let s=getRandomId();clearTimeout(e.timer),l.set(s,{res:r}),t.contentWindow.postMessage({type:"drillFrameTask",taskId:s,data:a.data},"*")});return window.addEventListener("message",o=(t=>{let{data:a,taskId:r}=t.data;if(l.has(r)){let e=l.get(r);l.delete(r),e.res(a)}l.size||(e.timer=setTimeout(n,1e4))})),new Promise((e,a)=>{t.addEventListener("load",t=>{e(c)}),t.addEventListener("error",e=>{n(),a()}),document.body.appendChild(t)})}),loaders.set("js",e=>new Promise((t,a)=>{let r=document.createElement("script");r.type="text/javascript",r.async=!0,r.src=e.link,r.addEventListener("load",async()=>{let a,{tempM:r}=base,{type:s}=r,i=processors.get(s||"file");if(!i)throw"no such this processor => "+s;a=await i(e),t(a)}),r.addEventListener("error",()=>{a()}),document.head.appendChild(r)}));try{eval('\n    loaders.set("mjs", async packData => {\n        let d = await import(packData.link);\n\n        return async () => {\n            return d;\n        }\n    });\n    ')}catch(e){console.warn("browser does not support asynchronous es module")}const returnUrlSets=new Set(["png","jpg","jpeg","bmp","gif","webp"]),getLoader=e=>{let t=loaders.get(e);return t||(t=getByUtf8),returnUrlSets.has(e)&&(t=getByUrl),t},getByUtf8=async e=>{let t=await fetch(e.link);return t=await t.text(),async()=>t},getByUrl=async e=>{if(e.offlineUrl)return async()=>e.offlineUrl;let t=await fetch(e.link),a=await t.blob(),r=URL.createObjectURL(a);return async()=>r},isHttpFront=e=>/^http/.test(e);class PackData{constructor(e){Object.assign(this,e),this.stat=1,this.passPromise=new Promise((e,t)=>{this._passResolve=e,this._passReject=t}),this.errPaths=[]}get dir(){return getDir(this.path)}get nextLink(){this.stat=2;let e=void 0!=this._backupId?++this._backupId:this._backupId=0,{backups:t}=errInfo,a=t[e-1]||base.baseUrl,r=t[e];if(!r)return;let s=getFullPath(a),i=getFullPath(r);this.errPaths.push(this.link);let l=this.link.replace(s,i);return this.link=l,l}resolve(e){this.getPack=e,this.stat=3,this._passResolve()}reject(){this.stat=4,this._passReject({desc:"load source error",link:this.errPaths,packData:this})}}let agent=async e=>{if(e.param&&e.param.includes("-getLink")&&!offline)return Promise.resolve(e.link);let t=bag.get(e.path);if(!t)for(t=new PackData({path:e.path,link:e.link,fileType:e.fileType}),bag.set(e.path,t);;)try{t.link=await cacheSource({packData:t});let a=await getLoader(e.fileType)(t)||(async()=>{});t.resolve(a);break}catch(a){if(t.stat=2,isHttpFront(e.str)){t.reject();break}if(!t.nextLink){t.reject();break}await new Promise(e=>setTimeout(e,errInfo.time))}return await t.passPromise,e.param&&e.param.includes("-getLink")&&offline?Promise.resolve(t.link):await t.getPack(e)};const drill={load:(...e)=>load(toUrlObjs(e)),remove(e){let{path:t}=fixUrlObj({str:e});if(bag.has(t))return bag.delete(t),!0;console.warn(`pack %c${e}`,"color:red","does not exist")},has(e){let{path:t}=fixUrlObj({str:e}),a=bag.get(t);return a&&a.stat},config(e){e.baseUrl&&(base.baseUrl=e.baseUrl);let t=e.paths;t&&Object.keys(t).forEach(e=>{let a=t[e];if(/^@.+\/$/.test(e)){let t="^"+e;a=a.replace(/\/\.\//,"/"),/^\.\./.test(a)?a=removeParentPath(getDir(document.location.href)+base.baseUrl+a):/^\//.test(a)&&(a=location.origin+a);let r=new RegExp(t);dirpaths[e]={reg:r,value:a}}else/^\w+$/.test(e)?paths.set(e,a):console.warn("this Paths settings do not meet specifications",e)}),base.baseUrl&&e.backups&&e.backups.forEach(e=>errInfo.backups.push(e))},ext(e,t){if(isFunction(e))e(base);else{let a,r=(...e)=>t(e,a,base);switch(e){case"fixUrlObj":a=fixUrlObj,fixUrlObj=r;break;case"load":a=load,load=r;break;case"agent":a=agent,agent=r;break;case"cacheSource":a=cacheSource,cacheSource=r}}},cacheInfo:{k:"d_ver",v:""},get offline(){return offline},set offline(e){offline?console.error("offline mode has been activated"):offline=e},debug:{bag:bag},version:"3.5.4",v:3005004},setProcessor=(e,t)=>{processors.set(e,async e=>{let a=base.tempM.d;return base.tempM={},await t(e,a,{relativeLoad:(...t)=>load(toUrlObjs(t,e.dir))})});let a=t=>{base.tempM={type:e,d:t}};drill[e]||(drill[e]=a),glo[e]||(glo[e]=a)},setCacheDress=(e,t)=>{cacheDress.set(e,async({file:e,packData:a})=>{let r=e,s=await e.text(),i=await t({fileText:s,file:e,relativeLoad:(...e)=>load(toUrlObjs(e,a.dir))});return s!==i&&(r=new File([i],e.name,{type:e.type})),r})};let load=e=>{let t,a=new Promise((a,r)=>{let s=[],{length:i}=e,l=i,n=[];e.forEach(async(e,o)=>{let c,p="succeed";await new Promise(e=>nextTick(e)),c=await agent(e).catch(t=>{p="error",Object.assign(e,{type:"error",descript:t}),n.push(e)}),s[o]=c,t&&t({id:o,sum:l,ready:l-i+1,stat:p}),--i||(n.length?r(n):a(1==l?c:s),s=null)})});return a.post=function(t){return e.forEach(e=>e.data=t),this},a.pend=function(e){return t=e,this},a},fixUrlObj=e=>{let t,a,r,s,i,{str:l,relative:n}=e;if(bag.has(l)){let t=bag.get(l);return Object.assign(e,{path:t.path,link:t.link}),e}[t,...i]=l.split(/\s/).filter(e=>e&&e),(r=t.match(/(.+)\?(\S+)$/)||"")&&(t=r[1],r=r[2]);let o=paths.get(t);if(o)t=o;else for(let e in dirpaths){let a=dirpaths[e];if(a.reg.test(t)){t=t.replace(a.reg,a.value);break}}/^.+:\/\//.test(t)||(t=i.includes("-r")?getFullPath(t):/^\./.test(t)?getFullPath(t,n||base.baseUrl):getFullPath(t,base.baseUrl)),t=t.replace(/\/\.\//,"/"),/\.\.\//.test(t)&&(t=removeParentPath(t)),(s=getFileType(t))||/\/$/.test(t)||(i.includes("-p")&&(t=t+"/"+t.replace(/.+\/(.+)/,"$1")),t+=".js",s="js"),a=r?t+"?"+r:t;{let{k:e,v:t}=drill.cacheInfo;e&&t&&!i.includes("-unCacheSearch")&&(a=a.includes("?")?`${a}&${e}=${t}`:`${a}?${e}=${t}`)}return i.includes("-mjs")&&(s="mjs"),Object.assign(e,{link:a,search:r,fileType:s,path:t.replace(location.origin,""),param:i}),e};const toUrlObjs=(e,t)=>{let a=getRandomId();return e.map((e,r)=>fixUrlObj({loadId:getRandomId(),id:r,str:e,groupId:a,relative:t}))};processors.set("file",e=>{}),setProcessor("define",async(e,t,{relativeLoad:a})=>{let r={},s={exports:r};if(isFunction(t)){let{path:i,dir:l}=e;t=t(a,r,s,{FILE:i,DIR:l})}return t instanceof Promise&&(t=await t),t||isEmptyObj(s.exports)||(t=s.exports),async()=>t}),setProcessor("task",(e,t,{relativeLoad:a})=>{if(!isFunction(t))throw"task must be a function";let{path:r,dir:s}=e;return async e=>{return await t(a,e.data,{FILE:r,DIR:s})}}),setProcessor("init",(e,t,{relativeLoad:a})=>{if(!isFunction(t))throw"init must be a function";let r,{path:s,dir:i}=e,l=0;return async e=>l?r:(r=await t(a,e.data,{FILE:s,DIR:i}),l=1,r)}),setCacheDress("css",async({fileText:e,relativeLoad:t})=>{let a=e.match(/@import ["'](.+?)["']/g);a&&await Promise.all(a.map(async a=>{let r=a.replace(/@import ["'](.+?)["']/,"$1"),s=await t(`${r} -getLink`);e=e.replace(a,`@import "${s}"`)}));let r=e.match(/url\((.+?)\)/g);return r&&await Promise.all(r.map(async a=>{let r=a.replace(/url\((.+?)\)/,"$1").replace(/["']/g,"");if(/(^http:)|(^https:)/.test(r))return Promise.resolve("");let s=await t(`${r} -getLink`);e=e.replace(a,`url("${s}")`)})),e}),setCacheDress("mjs",async({fileText:e,relativeLoad:t})=>{let a=e.match(/import .+ from ['"](.+?)['"];/g);a&&await Promise.all(a.map(async a=>{let r=a.match(/(import .+ from) ['"](.+?)['"];/,"$1");if(r){let s=r[2],i=await t(`${s} -getLink`);e=e.replace(a,`${r[1]} "${i}"`)}}));let r=e.match(/import\(.+?\)/g);return r&&await Promise.all(r.map(async a=>{let r=a.replace(/import\(["'](.+?)['"]\)/,"$1"),s=await t(`${r} -getLink`);e=e.replace(a,`import("${s}")`)})),e});const DBNAME="drill-cache-db",FILESTABLENAME="files";let mainDB,isInitDB=new Promise((e,t)=>{const a=glo.indexedDB||glo.webkitIndexedDB||glo.mozIndexedDB||glo.msIndexedDB;if(a){let t=a.open(DBNAME,drill.cacheInfo.v||1);t.onupgradeneeded=(e=>{let t=e.target.result;t.objectStoreNames.contains(FILESTABLENAME)?(t.deleteObjectStore(FILESTABLENAME),t.createObjectStore(FILESTABLENAME,{keyPath:"path"})):t.createObjectStore(FILESTABLENAME,{keyPath:"path"})}),t.onsuccess=(t=>{mainDB=t.target.result,e()})}else t("rubish browser no indexDB")}),cacheSource=async({packData:e})=>{if(!offline)return e.link;await isInitDB;let t=await getFile(e.path);if(!t){let a=await fetch(e.link);if(200!=a.status)throw{type:"cacheSource",desc:"statusError",status:a.status};let r=a.headers.get("Content-Type").replace(/;.+/,""),s=e.path.replace(/.+\//,""),i=await a.blob();t=new File([i],s,{type:r}),await saveFile(e.path,t)}let a=cacheDress.get(e.fileType);return a&&(t=await a({file:t,packData:e})),e.offlineFile=t,e.offlineUrl=URL.createObjectURL(t)};const getFile=e=>new Promise((t,a)=>{let r=mainDB.transaction([FILESTABLENAME],"readonly").objectStore(FILESTABLENAME).get(e);r.onsuccess=(()=>{t(r.result&&r.result.data)}),r.onerror=(t=>{a(),console.error(`error load ${e}`,t)})}),saveFile=(e,t)=>new Promise((a,r)=>{let s=mainDB.transaction([FILESTABLENAME],"readwrite").objectStore(FILESTABLENAME).put({path:e,data:t});s.onsuccess=(()=>{a({stat:1}),console.log(`save ${e} succeed`)}),s.onerror=(t=>{a({stat:0}),console.error(`save (${e}) error`,t)})});Object.defineProperty(base,"main",{value:{get agent(){return agent},get load(){return load},get fixUrlObj(){return fixUrlObj},get toUrlObjs(){return toUrlObjs},get setProcessor(){return setProcessor}}}),glo.load||(glo.load=drill.load);let cScript=document.currentScript;if(!cScript&&(cScript=document.querySelector(["drill-cache"])),cScript){let e=cScript.getAttribute("drill-cache");e&&(drill.cacheInfo.v=e)}let oldDrill=glo.drill;Object.defineProperty(glo,"drill",{get:()=>drill,set(e){isFunction(e)?nextTick(()=>e(drill)):console.error("drill type error =>",e)}}),oldDrill&&nextTick(()=>oldDrill(drill))})(window);